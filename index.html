<html>
<head>
  <style type="text/css">
    body {
      font-family: Verdana, Arial, sans-serif;
    }

    .legend {
      display: inline-block;
    }
    .legend-item {
      display: inline-block;
      padding: .4em .5em;
      min-width: 100%;
      cursor: pointer;
      color: rgb(111, 115, 136);
      font-size:90%;
    }
    .item:hover,
    .item-selected {
      background: rgb(215, 216, 222) !important;
    }

    .mode {
      display: inline-block;
    }
    .mode-item {
      display: inline-block;
      padding: .5em .5em;
      border-top: #6F7388 solid 2px;
      border-radius: 4px;
      min-width: 8em;
      cursor: pointer;
      border-bottom: none;
      font-size: 110% ;
      background: rgb(183, 185, 196);
      color: rgb(75, 80, 106);
    }

    .view-item{
      display: inline-block;
      padding: .4em .5em;
      cursor: pointer;
      color: rgb(111, 115, 136);
      font-size:90%;
    }

    .legend-color-box {
      display: inline-block;
      border-radius: 3px;
      width: .9em;
      height: .9em;
      vertical-align: middle;
      margin-right: .4em;
      margin-left: .2em;
    }

    /*
    .toggle-button {
      display: inline-block;
      padding: .3em .5em;
      min-width: 6em;
      background-color: #eee;
      cursor: pointer;
    }
    .toggle-button:hover {
      background-color: #999;
    }
    .toggle-button-disabled {
      background-color: #ccc;
    }*/
    .my-button{
      padding: .5em .5em;
      background: rgb(183, 185, 196);
      border-radius:6px;
      cursor:pointer;
      width: 5em;
      font-size: 100%;
      color: rgb(75, 113, 151);
      float:left;
    }
    .my-button:hover{
      background-color: rgb(215, 216, 222);
    }
    .my-button:disabled{
      color: rgb(147, 150, 166);
    }


  </style>
</head>
<body>
  <div style="white-space:nowrap;">
    <canvas id="label" ></canvas>
    <div style="display:inline-block;vertical-align:top;padding:0 1em;">

      <div id="mode" class="mode">
        <li class="mode-item item">Split</li><br> 
        <li class="mode-item item">Merge</li><br> 
        <li class="mode-item">Labels<br> 
            <div id="legend" class="legend"></div>
        </li>
      </div>
      <br>
      
      <div id="do-button" class="mode">
      <button id="undo-button" type="button" class="my-button" disabled=''>Undo</button>
      <button id="redo-button" type="button" class="my-button" disabled=''>Redo</button>
      </div>
      <br><br>
      <div id="view">
      <li class="mode-item">View<br>
        <input type="checkbox" id="boundary-button" checked onclick='handleClick();'><span class="view-item">Boundary</span><br>
        <input type="checkbox" id="fill-button" checked onclick='handleClick();'><span class="view-item">Fill</span>
      </li>
      </div><br>

      <button id="save-button" value="Save" type="button" class="my-button" style=" width: 10em;">Save</button>

    </div>
        <canvas id="part" ></canvas>
  </div>
  <script type="text/javascript">
//test_o: original image
//test_b: only with border
//test_l: border && part labels
//test_s: only with all Subsegment border
   // window.onload = function() {

      //loading label
         var img = new Image();
         //modeIndex: 0=split, 1=merge, 2=label
         window.labelColor, window.modeIndex;
         window.pushArray = new Array(), window.step = -1;
         window.mergeArray = new Array();
         img.onload = function() {
                var canvas = document.getElementById('label');
                canvas.width = img.width;
                canvas.height = img.height;
                window.context = canvas.getContext('2d');
                context.drawImage(img, 0, 0);
                window.label_imgData = context.getImageData(0, 0, img.width, img.height);       
                context.putImageData(label_imgData,0,0);
              
                var labels =[
                  {  name: 'Sky', color: [0, 0, 225]},
                  {  name: 'Cloud', color: [210, 0, 0]},
                  {  name: 'Clear label', color: [255, 255, 255]},
                ];
            //    initializeLegend(labels);

                initializeMode(labels);
                initializeContainListener();
                initializeButtons(); 

                loadImage('test_s.png',function(imgData, canvas){
                  window.Subseg_imgData = imgData;
                  window.sub_canvas = canvas;
                }); 
                loadImage('test_o.png',function(imgData, canvas){
                  window.ori_imgData = imgData;
                  window.ori_canvas = canvas;
                }); 
                loadImage('test_b.png',function(imgData, canvas){
                  window.border_imgData = imgData;
                  window.bor_canvas = canvas;
                  store();
                }); 

         }
         img.src = 'test_l.png';


      //0:split, 1:merge, 2:blue, 3:cloud, 4:clear
      function initializeMode(labels){
         function attachClickEvent(item, i) {
            item.addEventListener('click', function() {
               var selected = document.getElementsByClassName('item-selected')[0];
               if (selected)
                 selected.classList.remove('item-selected');
               this.classList.add('item-selected');

               if(i>=2){
                labelColor = labels[i-2];
                modeIndex = 2;
               }
               else
                modeIndex = i;
            });
         }
         for (var i = 0; i < labels.length; ++i) {
            var color = labels[i].color;
            var colorbox = document.createElement('span');
            colorbox.classList.add('legend-color-box');
            colorbox.style.backgroundColor =
                'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
            var label = document.createElement('div');
            label.classList.add('legend-item');
            label.classList.add('item');
            label.appendChild(colorbox);
            label.innerHTML += (labels[i].name);
            legend.appendChild(label);
            legend.appendChild(document.createElement('br'));
         }

         var item = document.getElementsByClassName('item');
         for (var i = 0; i < item.length; ++i) {
             attachClickEvent(item[i], i);
         }
        // currenIndex = label blue
         var currentIndex = 2;
         document.getElementsByClassName('item')[currentIndex].click();       
      }
         
       function loadImage(url, callback) {     
            var img = new Image();    
            img.onload = function(){
                var canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext('2d');
                context.drawImage(img, 0, 0);
                var imgData = context.getImageData(0, 0, img.width, img.height);  
                callback(imgData, canvas);
            }
            img.src = url; 
        }

        function store() {

            var data = {label:'', border:'', merge:[]};
            step++;
            if (step < pushArray.length) { pushArray.length = step; }
            data.label = document.getElementById('label').toDataURL();
            data.border = bor_canvas.toDataURL();
            data.merge = mergeArray.splice();
            pushArray.push(data);

            if(step > 0)
               document.getElementById('undo-button').disabled = false;
            if(step === pushArray.length-1)
               document.getElementById('redo-button').disabled = true;
         }


      function initializeContainListener(){
          var route, preHit, point, mousedown = false;

         //modeIndex: 0=split, 1=merge, 2=label
          var container = document.getElementById('label');
          container.addEventListener('mousedown', function(event) {
              var hit = getClickPosition(event, this);
              if(modeIndex ===1){
                 mousedown = true;
                 route = [];
                 preHit = getClickPosition(event, this);
                 route.push(preHit);
              }
          }, false);
          
          container.addEventListener('mousemove', function(event) {
            if(modeIndex===1 && mousedown){
              var hit = getClickPosition(event, this);
              route.push(hit);
              preHit = hit;          
             } 
          }, false);
        
          container.addEventListener('mouseup', function(event) {
             var hit = getClickPosition(event, this),
                 points = [];

             if(modeIndex===1){
                 for(var i =1; i<route.length;i++){
                  if(haveBorderWithin(route[i-1], route[i], label_imgData)){
                     points.push(route[i-1]);
                   }
                 }
                 if(!isBorder(hit.x, hit.y, label_imgData)){
                   points.push(hit);
                 }
             }
             else{
               points.push(hit);
             }

             mousedown = false;
             getSegmentPixels(points);

          }, false);
      }

      function haveBorderWithin(p, l, imgData){
          var x= p.x<=l.x ? 1:-1;
          var y= p.y<=l.y ? 1:-1;
          for(var i=p.x; i!=l.x; i=i+x){
            if(isBorder(i, p.y, imgData))
               return true;
          }
          for(var j=p.y; j!=l.y;j=j+y){
            if(isBorder(i, j, imgData))
              return true;
          }
          return false;
      }

      function dilateK(k, width, height, indexMap){
         var dilatePixels = [];
         manhattanDilate(width, height, indexMap);

         for (var y=0; y<height; y++){
             for (var x=0; x<width; x++){
                if(indexMap[y*width+x] <= k){
                   indexMap[y*width+x] = 1;
                   dilatePixels.push(y*width+x);
                }
                else{
                   indexMap[y*width+x] = 0;
                }
              }
          }
          
          return dilatePixels;
      }

      function manhattanDilate(width, height, indexMap){

           for (var y=0; y<height; y++){
               for (var x=0; x<width; x++){
                    if (indexMap[y*width+x] == 1){
                        indexMap[y*width+x] = 0;
                    } else {
                        indexMap[y*width+x] = height + width;
                        if (y>0) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[(y-1)*width+x]+1);
                        if (x>0) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[y*width+x-1]+1);
                    }
                }
            }

           for (var y = height-1; y >= 0; y--){
              for (var x = width-1; x >= 0; x--){
                    if (y+1 < height) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[(y+1)*width+x]+1);
                    if (x+1 < width) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[y*width+x+1]+1);
              }
           }
     }


     function manhattanErosion(width, height, indexMap){

           for (var y=0; y<height; y++){
               for (var x=0; x<width; x++){
                    if (indexMap[y*width+x] == 0){
                        indexMap[y*width+x] = 1;
                    } else {
                        indexMap[y*width+x] = -height - width;
                        if (y>0) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[(y-1)*width+x]-1);
                        if (x>0) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[y*width+x-1]-1);
                    }
                }
            }

           for (var y = height-1; y >= 0; y--){
              for (var x = width-1; x >= 0; x--){
                    if (y+1 < height) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[(y+1)*width+x]-1);
                    if (x+1 < width) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[y*width+x+1]-1);
              }
           }
     }     


      function erosionK(dilatePixels, pixels, ng_k, width, height, indexMap){

          manhattanErosion(width, height, indexMap);

          for(var i =0; i<dilatePixels.length;i++){
            if(indexMap[dilatePixels[i]] < ng_k && dilatePixels[i]>width && dilatePixels[i]<(height-1)*width && dilatePixels[i]%width!=0 && (dilatePixels[i]+1)%width!=0){
              pixels.push(dilatePixels[i]);
            }
          }

      }



      function isBorder(x, y, imgData){
        var k = y*img.width + x;

        if(imgData.data[4*k+0]===0 && imgData.data[4*k+1]===255 && imgData.data[4*k+2]===0)
          return true;
        return false;
      }

      function getClickPosition(e, parent){
         var mouse = {x:'', y:''};
         mouse.x = e.pageX - parent.offsetLeft + parent.scrollLeft;
         mouse.y = e.pageY - parent.offsetTop + parent.scrollTop;
         return mouse;

      //    consolze.log('Hit****  X:'+x+';'+'Y:'+y);
      };     

      //indexMap: pixel index = true, if this pixel is added into pixels Array
      function getSegmentPixels(point){
         var pixels = [], 
             k,
             mergeSegment = {state:'', no:''};
         var indexMap = new Array(img.width*img.height);
         
         for(var i=0; i< img.width*img.height;++i)
                indexMap[i] = 0;
         
         for(var i =0; i<point.length;i++){
            k = img.width*point[i].y + point[i].x;
            mergeSegment.state = false;

            for(var n=0; n<mergeArray.length; n++){
               for(var m=0; m<mergeArray[n].length; m++){

                  if(k===mergeArray[n][m]){
                    mergeSegment.state = true;
                    mergeSegment.no = n;
                    break;
                  }
               }
               if(mergeSegment.state)break;
            }

            if(mergeSegment.state){
               for(var t=0; t<mergeArray[mergeSegment.no].length; t++){
                  pixels.push(mergeArray[mergeSegment.no][t]);
                  indexMap[mergeArray[mergeSegment.no][t]] = 1;
               }
               mergeArray.splice(mergeSegment.no, 1);
            }
            else{
              getPixels(pixels, point[i].x, point[i].y,label_imgData.data, img.width, img.height, indexMap);
            }
         }

         updateSegments(pixels, indexMap);
      }
      


      function updateSegments(pixels, indexMap){
        switch(modeIndex){
          //split
           case 0:
             splitSegement(pixels);
             break;
           //merge  
           //k and ad can be further adjusted
           case 1: 
             var k=3;
             var dilatePixels = dilateK(k, img.width, img.height, indexMap);
             erosionK(dilatePixels, pixels, -k, img.width, img.height, indexMap);
             mergeArray.push(pixels);
             mergeSegment(pixels); 
             break;
           //label  
           case 2:
             mergeArray.push(pixels);
             labelSegment(pixels);
             break;
         }
         store();
      }



      //green border pixels never added into pixels array
      function getPixels(pixels, x, y, data, width, height, indexMap){
        var k = y*width + x;
        if (!indexMap[k] && !(isBorder(x, y, label_imgData))){
     
          pixels.push(k);
          indexMap[k]=1;
          if(x-1>0)
            getPixels(pixels, x-1, y, data, width, height, indexMap);
          if(x+1<height)
            getPixels(pixels, x+1, y, data, width, height, indexMap);
          if(y-1>0)
            getPixels(pixels, x, y-1, data, width, height, indexMap);
          if(y+1<width)
            getPixels(pixels, x, y+1, data, width, height, indexMap);
        }
      }
/*
     function drawPart(pixels){

                   var cvs = document.getElementById('part');
                   cvs.width = img.width;
                   cvs.height = img.height;
                   var ctx = cvs.getContext('2d');
                   var imPartData = ctx.getImageData(0, 0, cvs.width, cvs.height);
                   var data = label_imgData.data;

                  for(var i = 0; i < pixels.length; i++){
                        imPartData.data[4*pixels[i]+0] = data[4*pixels[i]+0];
                        imPartData.data[4*pixels[i]+1] = data[4*pixels[i]+1];
                        imPartData.data[4*pixels[i]+2] = data[4*pixels[i]+2];
                        imPartData.data[4*pixels[i]+3] = data[4*pixels[i]+3];
                  }

                  ctx.putImageData(imPartData,0,0);     
     }*/

      function saveImage(imgData){

                var cvs = document.createElement("canvas");
                cvs.width = img.width;
                cvs.height = img.height;
                var ctx = cvs.getContext('2d');
                var imData = ctx.getImageData(0, 0, cvs.width, cvs.height);
                imData.data.set(imgData.data);
                ctx.putImageData(imData,0,0); 

                var dataURL= cvs.toDataURL("image/png");

                return dataURL;    
      }


      function splitSegement(segPixels){

             for(var i = 0; i < segPixels.length; i++){
                 copyPixelColor(Subseg_imgData, label_imgData, segPixels[i]);
                 copyPixelColor(Subseg_imgData, border_imgData, segPixels[i]);
             }  
             context.putImageData(label_imgData,0,0);    

      }

      function mergeSegment(segPixels){

            for(var i=0; i<segPixels.length; i++){
                 copyPixelColor(ori_imgData, label_imgData, segPixels[i]);
                 copyPixelColor(ori_imgData, border_imgData, segPixels[i]);
            }   
            context.putImageData(label_imgData,0,0);      
      }

      function labelSegment(segPixels){

         if(labelColor.name =='Clear label'){
            for(var i=0; i<segPixels.length; i++){
                 copyPixelColor(ori_imgData, label_imgData, segPixels[i]);
            }         
         }
         else{
             for(var i = 0; i < segPixels.length; i++){
                 setPixelLabelColor(labelColor.color, label_imgData, segPixels[i]);
             }   
         }
         context.putImageData(label_imgData,0,0); 
      }
      

      function copyPixelColor(copyData, pasteData, k){
        pasteData.data[ 4*k+0] = copyData.data[4*k+0];
        pasteData.data[ 4*k+1] = copyData.data[4*k+1];
        pasteData.data[ 4*k+2] = copyData.data[4*k+2];
        pasteData.data[ 4*k+3] = copyData.data[4*k+3];
      }

      function setPixelLabelColor(color, imgData, k){
        imgData.data[4*k+0] = color[0];
        imgData.data[4*k+1] = color[1];
        imgData.data[4*k+2] = color[2];
        imgData.data[4*k+3] = 255;
      }

      function boundaryEnabled(width, height){
        var colorMap = new Array(width * height), 
            noBoundary_imgData = context.getImageData(0, 0, img.width, img.height),
            redPixels =[],
            bluePixels =[],       
            k;

            //expand blue
            for (var y =0; y< height; y++){
               for (var x =0; x<width; x++){
                    k = y*width+x;
                    if(label_imgData.data[4*k+0]===0 && label_imgData.data[4*k+1]===0 && label_imgData.data[4*k+2]>180){
                       colorMap[k]=1;
                    }
                    else
                       colorMap[k]=0;
                }
             }
             erosionK( dilateK(3, width, height, colorMap), bluePixels, 0, width, height, colorMap);

             for (var i=0;i<bluePixels.length;i++)
                setPixelLabelColor([0,0,194], noBoundary_imgData, bluePixels[i]);
  
             //expand red
             for (var y =0; y< height; y++){
                for (var x =0; x<width; x++){
                  k = y*width+x;
                  if(label_imgData.data[4*k+0]>180 && label_imgData.data[4*k+1]===0 && label_imgData.data[4*k+2]===0){
                       colorMap[k]=1;
                  }
                  else
                       colorMap[k]=0;
                  }
             }
             erosionK(dilateK(3, width, height, colorMap), redPixels, -1, width, height, colorMap); 

             for (var i=0;i<redPixels.length;i++)
                setPixelLabelColor([194,0,0], noBoundary_imgData, redPixels[i]);

             //rest green border
             for (var y =0; y< height; y++){
                for (var x =0; x<width; x++){
                   if(isBorder(x,y, noBoundary_imgData)){
                      k = y*width+x;
                      copyPixelColor(ori_imgData, noBoundary_imgData, k);
                   }
                }
              }
          return noBoundary_imgData;
            
      }
 
      



      // Create a slide radio input.
   /*   function createToggleButton(button, disableCallback, enableCallback) {
        var enabled = true;
        button.addEventListener('click', function() {
          if (enabled) {
            disableCallback();
            button.classList.add('toggle-button-disabled');
            enabled = !enabled;
          }
          else {
            enableCallback();
            button.classList.remove('toggle-button-disabled');
            enabled = !enabled;
          }
        });
      }
      // Create a local file input.
    /*  function createFileInput(button, callback) {
        var input = document.createElement('input');
        input.type = 'file';
        input.style.display = 'none';
        document.getElementsByTagName('body')[0].appendChild(input);
        input.addEventListener('change', function(event) {
          callback(event.target.files[0]);
        });
        button.addEventListener('click', function() {
          input.click();
        });
      }
      // Download as a file.      
      function downloadAsFile(url, filename) {
        var anchor = document.createElement('a');
        anchor.style.display = 'none';
        document.body.appendChild(anchor);
        anchor.setAttribute('href', url);
        anchor.setAttribute('download', filename);
        anchor.click();
        document.body.removeChild(anchor);
      };*/

      function handleClick(){
            var boundaryOn = document.getElementById('boundary-button').checked,
                fillOn = document.getElementById('fill-button').checked;
            if(boundaryOn && fillOn)
              context.putImageData(label_imgData,0,0);
            else if(boundaryOn) //fillOn = false
              context.putImageData(border_imgData,0,0);
            else if(fillOn)//boundaryOn = false
              context.putImageData(boundaryEnabled(img.width, img.height),0,0); 
            else// false, false
              context.putImageData(ori_imgData, 0, 0);
      }

      function downloadAsFile(url, filename) {
        var anchor = document.createElement('a');
        anchor.style.display = 'none';
        document.body.appendChild(anchor);
        anchor.setAttribute('href', url);
        anchor.setAttribute('download', filename);
        anchor.click();
        document.body.removeChild(anchor);
      };



      function checkFinishlabelling(imgData){
        var count = 0;
        for(var i =0; i<imgData.data.length/4; i=i+4){
          if((imgData.data[4*i+0]===0 && imgData.data[4*i+1]===0 && imgData.data[4*i+2]>180)||(imgData.data[4*i+0]>180 && imgData.data[4*i+1]===0 && imgData.data[4*i+2]===0)){}
          else{
            count++;
          }
          if(count>20)
            return false;
        }

        return true;
      }

      // Attach button events.
      function initializeButtons() {
        // Set up json importer.
  /*      createFileInput(document.getElementById('Open-button'), function(file) {
          if (file.type === 'application/json') {
            var reader = new FileReader();
            reader.onload = function(event) {
              var data = JSON.parse(event.target.result);
              annotator.setLabels(data.labels);
              annotator.setAnnotation(data.annotation);
              initializeLegend(annotator);
            };
            reader.readAsText(file);
          }
        });*/

    
        document.getElementById('save-button').addEventListener('click', function() {

          var finishData = boundaryEnabled(img.width, img.height);

          if(checkFinishlabelling(finishData)){
            var dataURL = saveImage(finishData);
            downloadAsFile(dataURL, 'labeled.png');
          }
          else{
            window.alert("Please finish labelling all segments :)");
          }
          
        });

        document.getElementById('undo-button').addEventListener('click', function() {

            if (step > 0) {
              step--;

              var undoLable = new Image();
              undoLable.onload = function(){
                context.drawImage(undoLable, 0, 0); 
                label_imgData = context.getImageData(0, 0, undoLable.width, undoLable.height);              
              }
              undoLable.src = pushArray[step].label;

              loadImage(pushArray[step].border, function(imgData, canvas){
                  border_imgData = imgData;
                  bor_canvas = canvas;
              })
              mergeArray = pushArray[step].merge.splice();

              document.getElementById('redo-button').disabled = false;
              if(step===0)
                document.getElementById('undo-button').disabled = true;
            }
        });

        document.getElementById('redo-button').addEventListener('click', function() {

             if (step < pushArray.length-1) {
                step++;

                var redoLable = new Image();
                redoLable.onload = function(){                
                  context.drawImage(redoLable, 0, 0); 
                  label_imgData = context.getImageData(0, 0, redoLable.width, redoLable.height);
                }
                redoLable.src = pushArray[step].label;

                loadImage(pushArray[step].border, function(imgData, canvas){
                    border_imgData = imgData;
                    bor_canvas = canvas;
                })
                mergeArray = pushArray[step].merge.splice();
                
                document.getElementById('undo-button').disabled = false;
                if(step === pushArray.length-1)
                  document.getElementById('redo-button').disabled = true;
             }
        });
      }
//    }
  </script>
</body>
</html>
