<html>
<head>
  <script type="text/javascript" src="pf-segmentation.js"></script>
  <script type="text/javascript" src="slic-segmentation.js"></script>
  <script type="text/javascript" src="segment-annotator.js"></script>
  <style type="text/css">
    body {
      font-family: Verdana, Arial, sans-serif;
    }
    .legend {
      display: inline-block;
    }
    .legend-item {
      display: inline-block;
      padding: .2em .5em;
      min-width: 8em;
      cursor: pointer;
      background-color: #eee;
    }
    .legend-item:hover {
      background-color: #999;
    }
    .legend-selected {
      background-color: #ccc;
    }

    .mode {
      display: inline-block;
    }
    .mode-item {
      display: inline-block;
      padding: .2em .5em;
      min-width: 8em;
      cursor: pointer;
      background-color: #eee;
    }
    .mode-item:hover {
      background-color: #999;
    }
    .mode-selected {
      background-color: #ccc;
    }


    .legend-delete-button {
      display: inline-block;
      padding: .2em .3em;
      cursor: pointer;
      background-color: #eee;
    }
    .legend-delete-button:hover {
      background-color: #999;
    }
    .legend-color-box {
      display: inline-block;
      border: #000 solid 1px;
      width: .8em;
      height: .8em;
      vertical-align: middle;
    }
    .toggle-button {
      display: inline-block;
      padding: .3em .5em;
      min-width: 6em;
      background-color: #eee;
      cursor: pointer;
    }
    .toggle-button:hover {
      background-color: #999;
    }
    .toggle-button-disabled {
      background-color: #ccc;
    }
    button{
      width: 12em;
      height:2em;
    }

  </style>
</head>
<body>
  <div style="white-space:nowrap;">
    <canvas id="label" ></canvas>
    <div style="display:inline-block;vertical-align:top;padding:0 1em;">
      <p>Mode</p>
      <div id="mode" class="mode"></div><br /> 
      <div id="legend" class="legend"></div>
      <button id="undo-button" type="button">Undo</button>
      <button id="redo-button" type="button">Redo</button> 
      <p>Views</p>
      <div>
        <div id="boundary-view-button" class="toggle-button">Boundary</div><br />
        <div id="fill-view-button" class="toggle-button">Fill</div>
      </div>
      <p>Source</p>
      <div>
        <div id="Open-button" class="toggle-button">Open</div><br />
        <div id="Save-button" class="toggle-button">Save</div>
      </div>
    </div>
        <canvas id="part" ></canvas>
  </div>
  <script type="text/javascript">
//test_o: original image
//test_b: only with border
//test_l: border && part labels
//test_s: only with all Subsegment border
   // window.onload = function() {

      //loading label
         var img = new Image();
         window.labelColor, window.modeIndex;
         window.pushArray = new Array(), window.step = -1;
         img.onload = function() {
                var canvas = document.getElementById('label');
                canvas.width = img.width;
                canvas.height = img.height;
                window.context = canvas.getContext('2d');
                context.drawImage(img, 0, 0);
                window.label_imgData = context.getImageData(0, 0, img.width, img.height);       
                context.putImageData(label_imgData,0,0);
              
                var labels =[
                  {  name: 'Sky', color: [0, 0, 194]},
                  {  name: 'Cloud', color: [194, 0, 0]},
                  {  name: 'Clear label', color: [255, 255, 255]},
                ];
                initializeLegend(labels);

                var mode = ['Label', 'Merge', 'Split'];
                initializeMode(mode);
                initializeButtons(); 

                loadImage('test_s.png',function(imgData, canvas){
                  window.Subseg_imgData = imgData;
                  window.sub_canvas = canvas;
                }); 
                loadImage('test_o.png',function(imgData, canvas){
                  window.ori_imgData = imgData;
                  window.ori_canvas = canvas;
                }); 
                loadImage('test_b.png',function(imgData, canvas){
                  window.border_imgData = imgData;
                  window.bor_canvas = canvas;
                  push();
                }); 

         }
         img.src = 'test_l.png';


         
       function loadImage(url, callback) {     
            var img = new Image();    
            img.onload = function(){
                var canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext('2d');
                context.drawImage(img, 0, 0);
                var imgData = context.getImageData(0, 0, img.width, img.height);  
                callback(imgData, canvas);
            }
            img.src = url; 
        }

        function push() {

            var data = {label:'', border:''};
            step++;
            if (step < pushArray.length) { pushArray.length = step; }
            data.label = document.getElementById('label').toDataURL();
            data.border = bor_canvas.toDataURL();
            pushArray.push(data);
            console.log("push:" +step);
         }

      var container = document.getElementById('label');
      container.addEventListener("click", function(event) {
             var hit = [];
             if(modeIndex!==1){
                hit.push(getClickPosition(event, this));
                getSegmentPixels(hit);             
             }

      }, false);


   //   function mergeSegement(){
          var route, preHit, point,
              mousestate = {down: false};

          container.addEventListener('mousedown', function(event) {
        //      console.log("*********");
              mousestate.down= true;
              var hit = getClickPosition(event, this);
        //      console.log('Start:   '+hit.x+','+hit.y);
              route = [];
              preHit = getClickPosition(event, this);
          }, false);
          
          container.addEventListener('mousemove', function(event) {
            if(mousestate.down){
              var hit = getClickPosition(event, this);
              route.push(hit);
              preHit = hit;          
             } 
          }, false);
        
          container.addEventListener('mouseup', function(event) {
             mousestate.down = false;
             var hit = getClickPosition(event, this);
             var points = [];
             for(var i =0; i<route.length;i++){
               if(isBorder(route[i].x, route[i].y, label_imgData)){
                 points.push(route[i-1]);
               }
             }
             if(!isBorder(hit.x, hit.y, label_imgData)){
               points.push(hit);
             }

             if(modeIndex==1)
            getSegmentPixels(points);

       //      console.log('Up:   '+hit.x+','+hit.y);
          }, false);
  //    }

      function dilateK(k, width, height, indexMap){
         var dilatePixels = [];
         manhattanDilate(width, height, indexMap);

         for (var y=0; y<height; y++){
             for (var x=0; x<width; x++){
                if(indexMap[y*width+x] <= k){
                   indexMap[y*width+x] = 1;
                   dilatePixels.push(y*width+x);
                }
                else{
                   indexMap[y*width+x] = 0;
                }
              }
          }
          
          return dilatePixels;
      }

      function manhattanDilate(width, height, indexMap){

           for (var y=0; y<height; y++){
               for (var x=0; x<width; x++){
                    if (indexMap[y*width+x] == 1){
                        indexMap[y*width+x] = 0;
                    } else {
                        indexMap[y*width+x] = height + width;
                        if (y>0) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[(y-1)*width+x]+1);
                        if (x>0) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[y*width+x-1]+1);
                    }
                }
            }

           for (var y = height-1; y >= 0; y--){
              for (var x = width-1; x >= 0; x--){
                    if (y+1 < height) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[(y+1)*width+x]+1);
                    if (x+1 < width) indexMap[y*width+x] = Math.min(indexMap[y*width+x], indexMap[y*width+x+1]+1);
              }
           }
     }


     function manhattanErosion(width, height, indexMap){

           for (var y=0; y<height; y++){
               for (var x=0; x<width; x++){
                    if (indexMap[y*width+x] == 0){
                        indexMap[y*width+x] = 1;
                    } else {
                        indexMap[y*width+x] = -height - width;
                        if (y>0) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[(y-1)*width+x]-1);
                        if (x>0) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[y*width+x-1]-1);
                    }
                }
            }

           for (var y = height-1; y >= 0; y--){
              for (var x = width-1; x >= 0; x--){
                    if (y+1 < height) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[(y+1)*width+x]-1);
                    if (x+1 < width) indexMap[y*width+x] = Math.max(indexMap[y*width+x], indexMap[y*width+x+1]-1);
              }
           }
     }     


      function erosionK(dilatePixels, pixels, ng_k, width, height, indexMap){

          var fake=[];

          manhattanErosion(width, height, indexMap);

          for(var i =0; i<dilatePixels.length;i++){
            if(indexMap[dilatePixels[i]] < ng_k){
              fake.push(dilatePixels[i]);
              pixels.push(dilatePixels[i]);
            }
          }

      }



      function isBorder(x, y, imgData){
        var k = y*img.width + x;

        if(imgData.data[4*k+0]===0 && imgData.data[4*k+1]===255 && imgData.data[4*k+2]===0)
          return true;
        return false;
      }

      function getClickPosition(e, parent){
         var mouse = {x:'', y:''};
         mouse.x = e.pageX - parent.offsetLeft + parent.scrollLeft;
         mouse.y = e.pageY - parent.offsetTop + parent.scrollTop;
         return mouse;

      //    consolze.log('Hit****  X:'+x+';'+'Y:'+y);
      };     

      //indexMap: pixel index = true, if this pixel is added into pixels Array
      function getSegmentPixels(point){
         var pixels = [];
         var indexMap = new Array(img.width*img.height);
         
         for(var i=0; i< img.width*img.height;++i)
                indexMap[i] = 0;
         
         for(var i =0; i<point.length;i++)
           getPixels(pixels, point[i].x, point[i].y,label_imgData.data, img.width, img.height, indexMap);

         switch(modeIndex){
          //label
           case 0:
             labelSegment(pixels);
             break;
           //merge  
           //k and ad can be further adjusted
           case 1: 
             var k=3;
             var dilatePixels = dilateK(k, img.width, img.height, indexMap);
             erosionK(dilatePixels, pixels, -k, img.width, img.height, indexMap);
             mergeSegment(pixels); 
             break;
           //split  
           case 2:
             splitSegement(pixels);
             break;
         }
         push();

         return pixels;
      }
      
/*
     function drawPart(pixels){

                   var cvs = document.getElementById('part');
                   cvs.width = img.width;
                   cvs.height = img.height;
                   var ctx = cvs.getContext('2d');
                   var imPartData = ctx.getImageData(0, 0, cvs.width, cvs.height);
                   var data = label_imgData.data;

                  for(var i = 0; i < pixels.length; i++){
                        imPartData.data[4*pixels[i]+0] = data[4*pixels[i]+0];
                        imPartData.data[4*pixels[i]+1] = data[4*pixels[i]+1];
                        imPartData.data[4*pixels[i]+2] = data[4*pixels[i]+2];
                        imPartData.data[4*pixels[i]+3] = data[4*pixels[i]+3];
                  }

                  ctx.putImageData(imPartData,0,0);     
     }*/


      function splitSegement(segPixels){

             for(var i = 0; i < segPixels.length; i++){
                 copyPixelColor(Subseg_imgData, label_imgData, segPixels[i]);
                 copyPixelColor(Subseg_imgData, border_imgData, segPixels[i]);
             }  
             context.putImageData(label_imgData,0,0);    

      }

      function mergeSegment(segPixels){

            for(var i=0; i<segPixels.length; i++){
                 copyPixelColor(ori_imgData, label_imgData, segPixels[i]);
                 copyPixelColor(ori_imgData, border_imgData, segPixels[i]);
            }   
            context.putImageData(label_imgData,0,0);       
      }

      function labelSegment(segPixels){

         if(labelColor.name =='Clear label'){
            for(var i=0; i<segPixels.length; i++){
                 copyPixelColor(ori_imgData, label_imgData, segPixels[i]);
            }         
         }
         else{
             for(var i = 0; i < segPixels.length; i++){
                 setPixelLabelColor(labelColor.color, label_imgData, segPixels[i]);
             }   
         }
         context.putImageData(label_imgData,0,0); 
      }
      

      function copyPixelColor(copyData, pasteData, k){
        pasteData.data[ 4*k+0] = copyData.data[4*k+0];
        pasteData.data[ 4*k+1] = copyData.data[4*k+1];
        pasteData.data[ 4*k+2] = copyData.data[4*k+2];
        pasteData.data[ 4*k+3] = copyData.data[4*k+3];
      }

      function setPixelLabelColor(color, imgData, k){
        imgData.data[4*k+0] = color[0];
        imgData.data[4*k+1] = color[1];
        imgData.data[4*k+2] = color[2];
        imgData.data[4*k+3] = 255;
      }

      function boundaryEnabled(width, height){
        var colorMap = new Array(width * height), 
            noBoundary_imgData = context.getImageData(0, 0, img.width, img.height),
            redPixels,
            bluePixels,       
            k;
                  
            noBoundary_imgData.data = label_imgData.data;

            //expand blue
            for (var y =0; y< height; y++){
               for (var x =0; x<width; x++){
                    k = y*width+x;
                    if(label_imgData.data[4*k+0]===0 && label_imgData.data[4*k+1]===0 && label_imgData.data[4*k+2]>180){
                       colorMap[k]=1;
                    }
                    else
                       colorMap[k]=0;
                }
             }
             bluePixels = dilateK(2, width, height, colorMap);

             for (var i=0;i<bluePixels.length;i++)
                setPixelLabelColor([0,0,194], noBoundary_imgData, bluePixels[i]);
  
             //expand red
             for (var y =0; y< height; y++){
                for (var x =0; x<width; x++){
                  k = y*width+x;
                  if(label_imgData.data[4*k+0]>180 && label_imgData.data[4*k+1]===0 && label_imgData.data[4*k+2]===0){
                       colorMap[k]=1;
                  }
                  else
                       colorMap[k]=0;
                  }
             }
             redPixels = dilateK(2, width, height, colorMap);   
             for (var i=0;i<redPixels.length;i++)
                setPixelLabelColor([194,0,0], noBoundary_imgData, redPixels[i]);

             //rest green border
             for (var y =0; y< height; y++){
                for (var x =0; x<width; x++){
                   if(isBorder(x,y, noBoundary_imgData)){
                      k = y*width+x;
                      copyPixelColor(ori_imgData, noBoundary_imgData, k);
                   }
                }
              }

            context.putImageData(noBoundary_imgData,0,0); 
 
      }
 

      //green border pixels never added into pixels array
     function getPixels(pixels, x, y, data, width, height, indexMap){
        var k = y*width + x;
        if (!indexMap[k] && !(isBorder(x, y, label_imgData))){
     
          pixels.push(k);
          indexMap[k]=1;
          if(x-1>0)
            getPixels(pixels, x-1, y, data, width, height, indexMap);
          if(x+1<height)
            getPixels(pixels, x+1, y, data, width, height, indexMap);
          if(y-1>0)
            getPixels(pixels, x, y-1, data, width, height, indexMap);
          if(y+1<width)
            getPixels(pixels, x, y+1, data, width, height, indexMap);
        }
      }
      

      function initializeMode(mode){
         function attachClickEvent(item, i) {
            item.addEventListener('click', function() {
               var selected = document.getElementsByClassName('mode-selected')[0];
               if (selected)
                 selected.classList.remove('mode-selected');
               modeIndex = i;
               this.classList.add('mode-selected');
            });
         }
         var legend = document.getElementById('mode');
         legend.innerHTML = '';
         for (var i = 0; i < mode.length; ++i) {
          // Create an item.
             var item = document.createElement('div');
             item.classList.add('mode-item');
             item.innerHTML += (' ' + mode[i]);
             legend.appendChild(item);
             attachClickEvent(item, i);
         }
         var currentIndex = Math.min(0, mode.length - 1);
         document.getElementsByClassName('mode-item')[currentIndex].click();       
      }


      function initializeLegend(labels){
        function attachClickEvent(item, i) {
          item.addEventListener('click', function() {
            var selected = document.getElementsByClassName('legend-selected')[0];
            if (selected)
              selected.classList.remove('legend-selected');
            labelColor = labels[i];
            this.classList.add('legend-selected');
          });
        }

        for (var i = 0; i < labels.length; ++i) {
          // Create an item.
          var color = labels[i].color;
          var colorbox = document.createElement('span');
          colorbox.classList.add('legend-color-box');
          colorbox.style.backgroundColor =
              'rgb(' + color[0] + ',' + color[1] + ',' + color[2] + ')';
          var item = document.createElement('div');
          item.classList.add('legend-item');
          item.appendChild(colorbox);
          item.innerHTML += (' ' + labels[i].name);
          legend.appendChild(item);
          attachClickEvent(item, i);

          legend.appendChild(document.createElement('br'));
        }
        var currentIndex = Math.min(0, labels.length - 1);
        document.getElementsByClassName('legend-item')[currentIndex].click();
      }


      // Create a slide radio input.
      function createToggleButton(button, disableCallback, enableCallback) {
        var enabled = true;
        button.addEventListener('click', function() {
          if (enabled) {
            disableCallback();
            button.classList.add('toggle-button-disabled');
            enabled = !enabled;
          }
          else {
            enableCallback();
            button.classList.remove('toggle-button-disabled');
            enabled = !enabled;
          }
        });
      }
      // Create a local file input.
      function createFileInput(button, callback) {
        var input = document.createElement('input');
        input.type = 'file';
        input.style.display = 'none';
        document.getElementsByTagName('body')[0].appendChild(input);
        input.addEventListener('change', function(event) {
          callback(event.target.files[0]);
        });
        button.addEventListener('click', function() {
          input.click();
        });
      }
      // Download as a file.      
      function downloadAsFile(url, filename) {
        var anchor = document.createElement('a');
        anchor.style.display = 'none';
        document.body.appendChild(anchor);
        anchor.setAttribute('href', url);
        anchor.setAttribute('download', filename);
        anchor.click();
        document.body.removeChild(anchor);
      };
      // Attach button events.
      function initializeButtons(annotator) {

        createToggleButton(document.getElementById('boundary-view-button'), function() {
            boundaryEnabled(img.width, img.height);
        }, function() {
            context.putImageData(label_imgData,0,0);
        });

        createToggleButton(document.getElementById('fill-view-button'), function() {
          context.putImageData(border_imgData,0,0); 
        }, function() {
          context.putImageData(label_imgData,0,0);
        });
        // Set up json importer.
        createFileInput(document.getElementById('Open-button'), function(file) {
          if (file.type === 'application/json') {
            var reader = new FileReader();
            reader.onload = function(event) {
              var data = JSON.parse(event.target.result);
              annotator.setLabels(data.labels);
              annotator.setAnnotation(data.annotation);
              initializeLegend(annotator);
            };
            reader.readAsText(file);
          }
        });
    /*
        document.getElementById('unlabel-button').addEventListener('click', function() {
         var img = new Image();
         img.src = 'test_o.png';
         img.onload = function() {
                var canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext('2d');
                context.drawImage(img, 0, 0);
                var imageData = context.getImageData(0, 0, img.width, img.height);       

                          var data = imageData.data;
                   var pixels = annotator.getPixelsIndex(2);
                   var cvs = document.getElementById('part');
                   cvs.width = img.width;
                   cvs.height = img.height;
                   var ctx = cvs.getContext('2d');
                   var imPartData = ctx.getImageData(0, 0, cvs.width, cvs.height);

                  for(var i = 0; i < pixels.length; i++){
                        imPartData.data[4*pixels[i]+0] = data[4*pixels[i]+0];
                        imPartData.data[4*pixels[i]+1] = data[4*pixels[i]+1];
                        imPartData.data[4*pixels[i]+2] = data[4*pixels[i]+2];
                        imPartData.data[4*pixels[i]+3] = data[4*pixels[i]+3];
                  }

                  ctx.putImageData(imPartData,0,0); 
         }
        });
*/
    
        document.getElementById('Save-button').addEventListener('click', function() {
          var data = {
            labels: annotator.getLabels(),
            annotation: annotator.getAnnotation()
          };
          var dataURL = 'data:application/json;charset=utf-8,' +
                        encodeURIComponent(JSON.stringify(data));
          downloadAsFile(dataURL, 'export.json');
        });

        document.getElementById('undo-button').addEventListener('click', function() {

            if (step > 0) {
              step--;

              var undoLable = new Image();
              undoLable.onload = function(){
                context.drawImage(undoLable, 0, 0); 
                label_imgData = context.getImageData(0, 0, undoLable.width, undoLable.height);              
              }
              undoLable.src = pushArray[step].label;

              loadImage(pushArray[step].border, function(imgData, canvas){
                  border_imgData = imgData;
                  bor_canvas = canvas;
              })

            }
        });

        document.getElementById('redo-button').addEventListener('click', function() {

             if (step < pushArray.length-1) {
                step++;

                var redoLable = new Image();
                redoLable.onload = function(){                
                  context.drawImage(redoLable, 0, 0); 
                  label_imgData = context.getImageData(0, 0, redoLable.width, redoLable.height);
                }
                redoLable.src = pushArray[step].label;

                loadImage(pushArray[step].border, function(imgData, canvas){
                    border_imgData = imgData;
                    bor_canvas = canvas;
                })
             }
        });
      }
//    }
  </script>
</body>
</html>
